#include <raylib.h>
#define RAYGUI_IMPLEMENTATION
#include "raygui.h"

#include <cstdlib>
#include <ctime>
#include <algorithm>


Vector2 Vector2Scale(Vector2 v, float scale) {
    return { v.x * scale, v.y * scale };
}
Vector2 Vector2Add(const Vector2& a, const Vector2& b) {
    return { a.x + b.x, a.y + b.y };
}

float nopeus = 400.0f;
bool rainbowMode = false;
Color bgColor = BLACK;
bool showScreenSaver = true;

bool show_debug = true;
bool show_debug_perma = false; // toggled by F1


Vector2 buttonSize = {80, 30};
Vector2 checkboxSize = {30, 30};

Vector2 jokuA, jokuB, jokuC;


Vector2 speedA = {1, 1};
Vector2 speedB = {1, -1};
Vector2 speedC = {-1, 1};


# Generated by dhcpcd from wlp2s0.dhcp

struct ColorFader {
    Color current;
    Color target;
    int speed; // how fast to fade each frame

    ColorFader(int fadeSpeed = 1) : speed(fadeSpeed) {
        current = { (unsigned char)(rand() % 256),
                    (unsigned char)(rand() % 256),
                    (unsigned char)(rand() % 256),
                    255 };
        target = { (unsigned char)(rand() % 256),
                   (unsigned char)(rand() % 256),
                   (unsigned char)(rand() % 256),
                   255 };
    }

    void Update() {
        auto fadeChannel = [](unsigned char &c, unsigned char t, int s) {
            if (c < t) c = (c + s > t) ? t : c + s;
            else if (c > t) c = (c - s < t) ? t : c - s;
        };

        fadeChannel(current.r, target.r, speed);
        fadeChannel(current.g, target.g, speed);
        fadeChannel(current.b, target.b, speed);

        // If all channels reached target, choose a new random target
        if (current.r == target.r && current.g == target.g && current.b == target.b) {
            target = { (unsigned char)(rand() % 256),
                       (unsigned char)(rand() % 256),
                       (unsigned char)(rand() % 256),
                       255 };
        }
    }
};


void drawUI() {
  DrawText(TextFormat("FPS: %d", GetFPS()), 10, 10, 20, PURPLE);

  // Slider: speed (pointer)
  GuiSlider((Rectangle){50, 220, 250, 20}, "Speed", TextFormat("%.1f", nopeus), &nopeus, 0.f, 4000.f);

  // Color picker (needs text + pointer)
  GuiColorPicker((Rectangle){50, 50, 150, 150}, "Player Color", &bgColor);

  // Example button
  if (GuiButton((Rectangle){50, 310, buttonSize.x, buttonSize.y}, "Reset")) {
      nopeus = 400.0f;
      bgColor = BLACK;
      rainbowMode = false;
  }

  GuiCheckBox((Rectangle){50, 260, checkboxSize.x, checkboxSize.y}, "Rainbow Mode", &rainbowMode);

}

void drawScreenSaver() {
  float deltaTime = GetFrameTime();
  int screenWidth = GetScreenWidth();
  int screenHeight = GetScreenHeight();
  
  DrawLineV(jokuA, jokuB, GREEN);
  DrawLineV(jokuB, jokuC, YELLOW);
  DrawLineV(jokuC, jokuA, BLUE);

  jokuA = Vector2Add(jokuA, Vector2Scale(speedA, nopeus * deltaTime));
  jokuB = Vector2Add(jokuB, Vector2Scale(speedB, nopeus * deltaTime));
  jokuC = Vector2Add(jokuC, Vector2Scale(speedC, nopeus * deltaTime));

  if (jokuA.x < 0 || jokuA.x > screenWidth)  speedA.x *= -1.0f;
  if (jokuA.y < 0 || jokuA.y > screenHeight) speedA.y *= -1.0f;

  // Kimpoamiset B:lle2
  if (jokuB.x < 0 || jokuB.x > screenWidth)  speedB.x *= -1.0f;
  if (jokuB.y < 0 || jokuB.y > screenHeight) speedB.y *= -1.0f;
  
  // Kimpoamiset C:lle
  if (jokuC.x < 0 || jokuC.x > screenWidth)  speedC.x *= -1.0f;
  if (jokuC.y < 0 || jokuC.y > screenHeight) speedC.y *= -1.0f;



}

void handleInput() {
    // F1 toggles permanent debug mode
    if (IsKeyReleased(KEY_F1)) {
        show_debug_perma = !show_debug_perma;
    }

    // TAB temporarily shows debug
    if (IsKeyDown(KEY_TAB)) {
        show_debug = true;
    } else {
        show_debug = show_debug_perma; // revert to permanent state
    }
}

int main() {
    srand(time(nullptr));
    // Initialize window and OpenGL context
    SetConfigFlags(FLAG_VSYNC_HINT); // enable VSync
    InitWindow(1200, 800, "Screensaver");
    jokuA = {(float)GetScreenWidth()/2, 0.0f};
    jokuB = {0.0f, (float)GetScreenHeight()/2};
    jokuC = {(float)GetScreenWidth(), (float)GetScreenHeight()*0.75f};



    ColorFader fader(1); // 1 = slow fade, increase for faster

    // Main game loop
    while (!WindowShouldClose()) {

        // Begin drawing
        BeginDrawing();
        ClearBackground(bgColor);
        handleInput();
        if(showScreenSaver) {
          drawScreenSaver();
        }
      
        if(show_debug||show_debug_perma) {
          drawUI();
        }

        if (rainbowMode) {
          fader.speed = std::max((nopeus/50)*GetFrameTime(), 1.0f);
          fader.Update();
          bgColor = fader.current;

        }



        // End drawing
        EndDrawing();
    }

    // De-initialize the window and OpenGL context
    CloseWindow();

    return 0;
}

